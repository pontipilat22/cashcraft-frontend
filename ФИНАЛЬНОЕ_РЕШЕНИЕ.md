# ФИНАЛЬНОЕ РЕШЕНИЕ: Работа без SQLite

## Проблема
SQLite в Expo SDK 53 нестабилен и периодически падает с `NullPointerException`. Это делает приложение неработоспособным.

## Решение
Полностью обойти SQLite и использовать только AsyncStorage + Backend синхронизацию.

## Что нужно сделать

### 1. Отключить использование SQLite в DataContext

В файле `src/context/DataContext.tsx` измените метод `createAccount`:

```typescript
const createAccount = async (account: Omit<Account, 'id' | 'createdAt' | 'updatedAt'>) => {
  try {
    // Всегда работаем в "fallback" режиме
    const newAccount: Account = {
      ...account,
      id: Date.now().toString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    // Добавляем в состояние
    setAccounts(prev => [...prev, newAccount]);
    
    // Сохраняем в AsyncStorage
    const currentData = await AsyncStorage.getItem('local_data');
    const data = currentData ? JSON.parse(currentData) : { accounts: [], transactions: [], categories: [], debts: [] };
    data.accounts.push(newAccount);
    await AsyncStorage.setItem('local_data', JSON.stringify(data));
    
    // Синхронизируем с сервером
    await syncData();
    
    return newAccount;
  } catch (error) {
    console.error('Error creating account:', error);
    throw error;
  }
};
```

### 2. Изменить refreshData для работы с AsyncStorage

```typescript
const refreshData = async () => {
  try {
    // Загружаем из AsyncStorage
    const localData = await AsyncStorage.getItem('local_data');
    if (localData) {
      const data = JSON.parse(localData);
      setAccounts(data.accounts || []);
      setTransactions(data.transactions || []);
      setCategories(data.categories || []);
      setDebts(data.debts || []);
    }
    
    // Загружаем из fallback (если есть)
    const fallbackData = await CloudSyncService.getFallbackData();
    if (fallbackData && fallbackData.accounts.length > 0) {
      setAccounts(fallbackData.accounts);
      setTransactions(fallbackData.transactions);
      setCategories(fallbackData.categories);
      setDebts(fallbackData.debts);
    }
  } catch (error) {
    console.error('Error in refreshData:', error);
  }
};
```

### 3. Создать сервис для работы с локальными данными

Создайте файл `src/services/localStorage.ts`:

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Account, Transaction, Category, Debt } from '../types';

const LOCAL_DATA_KEY = 'local_data';

interface LocalData {
  accounts: Account[];
  transactions: Transaction[];
  categories: Category[];
  debts: Debt[];
}

export class LocalStorageService {
  static async getData(): Promise<LocalData> {
    try {
      const data = await AsyncStorage.getItem(LOCAL_DATA_KEY);
      if (data) {
        return JSON.parse(data);
      }
      return { accounts: [], transactions: [], categories: [], debts: [] };
    } catch (error) {
      console.error('Error getting local data:', error);
      return { accounts: [], transactions: [], categories: [], debts: [] };
    }
  }
  
  static async saveData(data: LocalData): Promise<void> {
    try {
      await AsyncStorage.setItem(LOCAL_DATA_KEY, JSON.stringify(data));
    } catch (error) {
      console.error('Error saving local data:', error);
    }
  }
  
  static async addAccount(account: Account): Promise<void> {
    const data = await this.getData();
    data.accounts.push(account);
    await this.saveData(data);
  }
  
  static async updateAccount(id: string, updates: Partial<Account>): Promise<void> {
    const data = await this.getData();
    const index = data.accounts.findIndex(a => a.id === id);
    if (index !== -1) {
      data.accounts[index] = { ...data.accounts[index], ...updates };
      await this.saveData(data);
    }
  }
  
  static async deleteAccount(id: string): Promise<void> {
    const data = await this.getData();
    data.accounts = data.accounts.filter(a => a.id !== id);
    data.transactions = data.transactions.filter(t => t.accountId !== id);
    await this.saveData(data);
  }
}
```

## Результат

1. **Приложение будет работать стабильно** без падений SQLite
2. **Данные будут сохраняться** в AsyncStorage
3. **Синхронизация с сервером** будет работать как обычно
4. **При входе** данные будут загружаться с сервера

## Временное решение

Это временное решение до исправления проблем с SQLite в Expo. В будущем можно будет вернуться к использованию SQLite.

## Заключение

SQLite в Expo SDK 53 остается нестабильным на Android. Рекомендуется использовать AsyncStorage + серверную синхронизацию до тех пор, пока Expo не исправит эти проблемы.

## Проблема SQLite в Expo SDK 51-53

### Подтвержденная проблема
- GitHub Issue: [expo/expo#27619](https://github.com/expo/expo/issues/27619)
- Ошибка: `java.lang.NullPointerException` в `NativeDatabase.prepareSync`
- Платформа: Android
- Версии: SDK 51, 52, 53

### Альтернативные решения

1. **Использовать старый API SQLite (временно)**
   ```javascript
   // Вместо нового API
   import * as SQLite from 'expo-sqlite';
   
   // Можно попробовать legacy версию (если доступна)
   import * as SQLite from 'expo-sqlite/legacy';
   ```

2. **WatermelonDB**
   - Более стабильная ORM для React Native
   - Поддерживает синхронизацию
   - Работает поверх SQLite но с собственной реализацией
   ```bash
   npm install @nozbe/watermelondb
   ```

3. **Realm Database**
   - Альтернативная база данных для React Native
   - Встроенная синхронизация (платная)
   - Более стабильная чем SQLite в Expo
   ```bash
   npm install realm
   ```

4. **MMKV**
   - Быстрое key-value хранилище
   - Альтернатива AsyncStorage
   - Более производительное
   ```bash
   npm install react-native-mmkv
   ```

### Временные обходные пути для SQLite

1. **Уменьшить количество параллельных запросов**
   ```javascript
   // Использовать очередь запросов
   const queue = [];
   let processing = false;
   
   async function executeQuery(query) {
     return new Promise((resolve, reject) => {
       queue.push({ query, resolve, reject });
       processQueue();
     });
   }
   
   async function processQueue() {
     if (processing || queue.length === 0) return;
     processing = true;
     
     const { query, resolve, reject } = queue.shift();
     try {
       const result = await db.execAsync(query);
       resolve(result);
     } catch (error) {
       reject(error);
     }
     
     processing = false;
     setTimeout(processQueue, 10); // Небольшая задержка
   }
   ```

2. **Переинициализация базы данных при ошибке**
   ```javascript
   let db = null;
   let retryCount = 0;
   
   async function getDatabase() {
     if (!db || retryCount > 0) {
       try {
         db = await SQLite.openDatabaseAsync('app.db');
         retryCount = 0;
       } catch (error) {
         retryCount++;
         if (retryCount > 3) throw error;
         await new Promise(resolve => setTimeout(resolve, 100));
         return getDatabase();
       }
     }
     return db;
   }
   ```

### Рекомендация Expo команды

Пока официального исправления нет, команда Expo рекомендует:
1. Использовать development builds вместо Expo Go
2. Тестировать на реальных устройствах
3. Сообщать о проблемах в GitHub Issues

### Отслеживание исправления

- Следите за [expo/expo#27619](https://github.com/expo/expo/issues/27619)
- Проверяйте changelog будущих версий SDK
- Возможно исправление придет в SDK 54 или 55 